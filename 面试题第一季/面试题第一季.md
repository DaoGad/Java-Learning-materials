---
typora-root-url: images
---

# 面试题第一季

## 1、自增变量

```java
  public static void main(String[] args) {
        int i = 1;
        i = i++;
        int j = i++;
        int k = i + ++i * i++;
        System.out.println("i=" + i);
        System.out.println("j=" + j);
        System.out.println("k=" + k);

    }
```

![](/Snipaste_2020-09-22_13-18-59.png)

> 执行 i = i++; 先将i变量压入操作数栈，然再对i变量进行自增,最后把计算结果赋值给  i , i 任然是1

![](/Snipaste_2020-09-22_13-24-00.png)

i++ 计算后将值给到 j 

![](/Snipaste_2020-09-22_13-25-04.png)

最后一步

![](/Snipaste_2020-09-22_13-26-36.png)





## 2、单例模式

### 什么事Singleton?

Singleton:在Java中 即指单例设置模式，探视软件开发最常用的设置模式之一

单：唯一

例：实例

单例设计模式，即某个类在整个系统中只能有一个实例对象可被获取和使用的代码模式

例如：代表JVM运行环境的Runtime类

### 要点：

##### 一是某个类只能有一个实例

​	构造器私有化

##### 二是他必须自行创建实例

​	含有一个该类的静态变量来保存这个唯一的实例

##### 三是它必须自行向整个系统提供这个实例

​	对外提供获取该类实例对象的方式

- 直接暴露
- 用静态变量的get方法获取



### 几种常见形式

#### 饿汉式：直接创建对象，不存在线程安全问题

> ​	直接实例化饿汉式(简洁直观)
>
> ​	枚举式 (最简洁)
>
> ​	静态代码块饿汉式(适合复杂实例化)



#### 懒汉式;延迟创建对象

> ​	线程不安全(使用于单线程)
>
> ​	线程安全(使用于多线程)
>
> ​	静态内部类模式  (适用于多线程)



### 饿汉式

##### 直接实例化饿汉式(简洁直观)

```java
public class Singleton1 {
    /**
     * 1、构造器私有化
     * 2、自行创建，并且用静态变量保存
     * 3、向外提供实例
     * 4、强调这是一个单例，我们可以用final修改
     */
    private Singleton1() {

    }
    public static final Singleton1 INSTANCE = new Singleton1();

}
```

##### 枚举式 (最简洁)

```java
public enum  Singleton2 {
    /**
     * 枚举类型：表示该类型是有限的几个
     */
    INSTANCE
}
```

##### 	静态代码块饿汉式(适合复杂实例化)

```java
public class Singleton3 {
    /**
     *  静态代码块
     */
    public static final Singleton3 INSTANCE;
    private String info;

    static {
        try {
            INSTANCE = new Singleton3("123");
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }
    private Singleton3(String info) {
        this.info = info;
    }
}
```

### 懒汉式

##### 线程不安全(使用于单线程)

```java
public class Singleton4 {
    /**
     * 1、构造器私有化
     * 2、用一个静态变量保存这个唯一的实例
     * 3、提供一个静态方法，获取这个实例对象
     */
    static Singleton4 instance;
    private Singleton4() {}

    public static Singleton4 getInstance() {
            if (instance == null) {
                instance = new Singleton4();
            }
            return instance;

    }
}
```

##### 线程安全(使用于多线程)

```java
public class Singleton5 {
    /**
     * 1、构造器私有化
     * 2、用一个静态变量保存这个唯一的实例
     * 3、提供一个静态方法，获取这个实例对象
     */
    static Singleton5 instance;
    private Singleton5() {}

    public static Singleton5 getInstance() {
        if (instance == null) {
            synchronized (Singleton5.class) {
                if (instance == null) {
                    instance = new Singleton5();
                }
                return instance;
            }
        }
        return instance;
    }
}
```

##### 静态内部类模式  (适用于多线程)

```java
public class Singleton6 {
    /**
     * 1、内部类被加载和初始化时，才创建INSTANCE实例对象
     * 2、静态内部类不会自动创建,随着外部类的加载初始化而初始化，他是要单独去加载和实例化的
     * 3、因为是在内部类加载和初始化时，创建的，因此线程安全
     */
    private Singleton6(){}

    public static class Inner{
        private static final Singleton6 INSTANCE = new Singleton6();
    }
    public static Singleton6 getInstance() {
        return Inner.INSTANCE;
    }
}
```



## 3、类初始化实例初始化

### 类初始化

> 一个类要创建实例需要先加载并初始化该类
>
> ​		main方法所在的类需要先加载和初始化
>
> 一个子类要初始化需要先初始化父类
>
> 一个类初始化就是执行<clinit>()方法
>
> ​		<clinit>()方法由静态类变量显示赋值代码和静态代码块组成
>
> ​		类变量显示赋值代码和静态代码块代码从上到下执行
>
> ​		<clinit>()方法只调用一次

### 实例初始化过程

> 实例初始化就是执行<init>()方法
>
> ​	<init>()方法可能重载有多个，有几个构造器就有几个<init>()方法
>
> ​	<init>()方法由非静态实例变量显示赋值代码和非静态代码块，对应构造器代码组成
>
> ​	非静态实例变量显示赋值代码和非静态代码块从上到下顺序执行，而对应构造器的代码最后执行
>
> ​	每次创建实例对象，调用对应构造器，执行的就是对应的<init>方法
>
> ​	<init>方法的首行是super()和super(实参列表) ,即对应父类的<init>方法

##### Father.java

```java
package com.atguigu.classLoader;

/**
 * 父类初始化<clinit>
 * 1、j = method()
 * 2、 父类的静态代码块
 *
 * 父类实例化方法:
 * 1、super()（最前）
 * 2、i = test() (9)
 * 3、子类的非静态代码块 (3)
 * 4、子类的无参构造（最后）(2)
 *
 *
 * 非静态方法前面其实有一个默认的对象this
 * this在构造器或<init> 他表示的是正在创建的对象，因为咱们这里是正在创建Son对象，所以
 * test()执行的就是子类重写的代码(面向对象多态)
 *
 * 这里i=test() 执行的就是子类重写的test()方法
 * @author gcq
 * @Create 2020-09-25
 */
public class Father {
    private int i = test();
    private static int j = method();

    static{
        System.out.println("(1)");
    }
    Father() {
        System.out.println("(2)");
    }
    {
        System.out.println("(3)");
    }
    public int test(){
        System.out.println("(4)");
        return 1;
    }
    public static int method() {
        System.out.println("(5)");
        return 1;
    }
}
```

##### Son.java

```java
package com.atguigu.classLoader;

/**
 * 子类的初始化<clinit>
 * 1、j = method()
 * 2、子类的静态代码块
 *
 * 先初始化父类 (5)(1)
 * 初始化子类 (10) (6)
 *
 * 子类实例化方法:
 * 1、super()（最前
 * 2、i = test() (9)
 * 3、子类的非静态代码块 (8)
 * 4、子类的无参构造（最后）(7)
 * @author gcq
 * @Create 2020-09-25
 */
public class Son extends Father {
    private int i = test();
    private static int j = method();
    static {
        System.out.println("(6)");
    }
    Son() {
        super();
        System.out.println("(7)");
    }
    {
        System.out.println("(8)");
    }
    public int test(){
        System.out.println("(9)");
        return 1;
    }
    public static int method() {
        System.out.println("(10)");
        return 1;
    }

    public static void main(String[] args) {
        Son son = new Son();
        System.out.println();
        Son son1 = new Son();
    }
}
```

执行结果

```java
(5)
(1)
(10)
(6)
(9)
(3)
(2)
(9)
(8)
(7)

(9)
(3)
(2)
(9)
(8)
(7)
```



## 4、方法参数传递机制

代码：

```java
package com.atguigu.methodParam;

import java.util.Arrays;

/**
 * @author gcq
 * @Create 2020-09-28
 */
public class Exam4 {
    public static void main(String[] args) {
        int i = 1;
        String str = "hello";
        Integer num = 200;
        int[] arr = {1,2,3,4,5};
        MyData my = new MyData();

        change(i,str,num,arr,my);

        // arr my变了
        System.out.println("i= " + i);
        System.out.println("str= " + str);
        System.out.println("num= " + num);
        System.out.println("arr= " + Arrays.toString(arr));
        System.out.println("my.a= " + my.a);

    }
    public static void change(int j, String s, Integer n, int[] a, MyData m) {
        j += 1;
        s += "world";
        n += 1;
        a[0] += 1;
        m.a += 1;
    }
}
class MyData {
    int a = 10;

}
```

### 考点？

方法的参数传递机制

String、包装类等对象的不可变性



### 方法的参数传递机制

1、形参是基本数据类型

​	传递数据值

2、实参是引用数据类型

​	传递地址值

​	特殊的类型：String、包装类等对象的不可变性

![](/../../JavaSE/images/Snipaste_2020-09-28_13-36-29.png)













